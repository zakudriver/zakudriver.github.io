{"categories":[{"title":"balabala","uri":"https://rx-78-kum0.github.io/categories/balabala/"},{"title":"code","uri":"https://rx-78-kum0.github.io/categories/code/"},{"title":"configuration","uri":"https://rx-78-kum0.github.io/categories/configuration/"}],"posts":[{"content":" 相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中。\n package main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/gomodule/redigo/redis\u0026quot; ) // ConsumeFunc consumes message at the channel. type ConsumeFunc func(channel string, message []byte) error // RedisClient represents a redis client with connection pool. type RedisClient struct { pool *redis.Pool } // NewRedisClient returns a RedisClient. func NewRedisClient(addr string, passwd string) *RedisClient { pool := \u0026amp;redis.Pool{ MaxIdle: 10, IdleTimeout: 300 * time.Second, Dial: func() (redis.Conn, error) { c, err := redis.Dial(\u0026quot;tcp\u0026quot;, addr, redis.DialPassword(passwd), redis.DialDatabase(0)) if err != nil { return nil, err } return c, nil }, TestOnBorrow: func(c redis.Conn, t time.Time) error { if time.Since(t) \u0026lt; time.Minute { return nil } _, err := c.Do(\u0026quot;PING\u0026quot;) return err }, } log.Printf(\u0026quot;new redis pool at %s\u0026quot;, addr) client := \u0026amp;RedisClient{ pool: pool, } return client } // Close closes connection pool. func (r *RedisClient) Close() error { err := r.pool.Close() return err } // Publish publishes message to channel. func (r *RedisClient) Publish(channel, message string) (int, error) { c := r.pool.Get() defer c.Close() n, err := redis.Int(c.Do(\u0026quot;PUBLISH\u0026quot;, channel, message)) if err != nil { return 0, fmt.Errorf(\u0026quot;redis publish %s %s, err: %v\u0026quot;, channel, message, err) } return n, nil } // Subscribe subscribes messages at the channels. func (r *RedisClient) Subscribe(ctx context.Context, consume ConsumeFunc, channel ...string) error { psc := redis.PubSubConn{Conn: r.pool.Get()} log.Printf(\u0026quot;redis pubsub subscribe channel: %v\u0026quot;, channel) if err := psc.Subscribe(redis.Args{}.AddFlat(channel)...); err != nil { return err } done := make(chan error, 1) // start a new goroutine to receive message go func() { defer psc.Close() for { switch msg := psc.Receive().(type) { case error: done \u0026lt;- fmt.Errorf(\u0026quot;redis pubsub receive err: %v\u0026quot;, msg) return case redis.Message: if err := consume(msg.Channel, msg.Data); err != nil { done \u0026lt;- err return } case redis.Subscription: if msg.Count == 0 { // all channels are unsubscribed done \u0026lt;- nil return } } } }() ch \u0026lt;- 0 // health check tick := time.NewTicker(time.Minute) defer tick.Stop() for { select { case \u0026lt;-ctx.Done(): if err := psc.Unsubscribe(); err != nil { return fmt.Errorf(\u0026quot;redis pubsub unsubscribe err: %v\u0026quot;, err) } return nil case err := \u0026lt;-done: return err case \u0026lt;-tick.C: if err := psc.Ping(\u0026quot;\u0026quot;); err != nil { return err } log.Println(\u0026quot;over\u0026quot;) return nil } } } func myConsumer(channel string, message []byte) error { log.Printf(\u0026quot;receive message[%s] at the channel[%s]\\n\u0026quot;, string(message), channel) return nil } // ch 用于保证发布线程在订阅线程启动成功后才开始发布消息 var ch = make(chan int) func main() { redisClient := NewRedisClient(\u0026quot;127.0.0.1:6300\u0026quot;, \u0026quot;zyhua1122\u0026quot;) defer redisClient.Close() go func() { var subscriber int \u0026lt;-ch for i := 0; i \u0026lt; 3; i++ { subscriber, _ = redisClient.Publish(\u0026quot;testx\u0026quot;, \u0026quot;hello world\u0026quot;+strconv.Itoa(i)) log.Printf(\u0026quot;there is %d subscriber.\\n\u0026quot;, subscriber) } }() ctx, cancel := context.WithCancel(context.Background()) err := redisClient.Subscribe(ctx, func(channel string, message []byte) error { log.Printf(\u0026quot;receive message[%s] at the channel[%s]\\n\u0026quot;, string(message), channel) if string(message) == \u0026quot;goodbye\u0026quot; { cancel() } return nil }, \u0026quot;testx\u0026quot;) if err != nil { fmt.Printf(\u0026quot;get error: %v\\n\u0026quot;, err) } return }  ","id":0,"section":"posts","summary":"相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，","tags":["golang"],"title":"redis发布订阅","uri":"https://rx-78-kum0.github.io/2020/07/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","year":"2020"},{"content":"package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++ { wg.Add(1) value := i g.Run(func() { // 做一些业务逻辑处理 fmt.Printf(\u0026quot;go func: %d\\n\u0026quot;, value) time.Sleep(time.Second) wg.Done() }) } wg.Wait() }  ","id":1,"section":"posts","summary":"package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++","tags":["golang"],"title":"限制goroutine数量","uri":"https://rx-78-kum0.github.io/2020/07/%E9%99%90%E5%88%B6goroutine%E6%95%B0%E9%87%8F/","year":"2020"},{"content":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026quot;unsafe\u0026quot; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) }  避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026quot;拼接字符串 package string_utils import ( \u0026quot;strings\u0026quot; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() }  ","id":2,"section":"posts","summary":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026quot;unsafe\u0026quot; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h","tags":["golang"],"title":"golang gc优化","uri":"https://rx-78-kum0.github.io/2020/06/gc%E4%BC%98%E5%8C%96/","year":"2020"},{"content":"package util-time import ( \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026quot;2006/01/02 15:04:05\u0026quot;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026quot;Asia/Shanghai\u0026quot;) t := time.Now().In(cstSh).Format(\u0026quot;2006/01/02/ 15:04:05\u0026quot;) return t } func GetCurrentHour() int { var cstSh, _ = time.LoadLocation(\u0026quot;Asia/Shanghai\u0026quot;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026quot;2006010215\u0026quot;)) return t } func GetCurrentDay() int { var cstSh, _ = time.LoadLocation(\u0026quot;Asia/Shanghai\u0026quot;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026quot;20060102\u0026quot;)) return t } func GetLastDay() int { var cstSh, _ = time.LoadLocation(\u0026quot;Asia/Shanghai\u0026quot;) nTime := time.Now() t,_ := strconv.Atoi(nTime.AddDate(0,0,-1).In(cstSh).Format(\u0026quot;20060102\u0026quot;)) return t } func GetlastHour() int { nTime := time.Now() lastTime := nTime.Add(time.Hour * -1) t,_ := strconv.Atoi(lastTime.Format(\u0026quot;2006010215\u0026quot;)) return t }  ","id":3,"section":"posts","summary":"package util-time import ( \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026quot;2006/01/02 15:04:05\u0026quot;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return","tags":["golang"],"title":"golang time工具函数","uri":"https://rx-78-kum0.github.io/2020/06/time/","year":"2020"},{"content":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。相反，如果该位是\u0026quot;1\u0026rdquo;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。\n  D/B: \u0026ldquo;默认的操作数大小\u0026rdquo;(Default Operation Size)或者\u0026quot;默认的堆栈指针大小\u0026rdquo;，又或者\u0026quot;上部边界\u0026quot;标志。设立该标志位，主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序。D＝0 表示指令中的偏移地址或者操作数是 16 位的； D＝1，指示 32 位的偏移地址或者操作数。\n  L: 64 位代码段标志。保留此位给 64 位处理器使用。32位将此位置\u0026quot;0\u0026rdquo;。\n  AVL: 保留位。可以被系统软件使用。\n  P: 段存在位(Segment Present)。 P 位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的 P 位清零，表示段并不存在。P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果 P 位是\u0026quot;0\u0026rdquo;，处理器就会产生一个异常中断。\n  DPL: 描述符的特权级(Descriptor Privilege Level， DPL)。这两位用于指定段的特权级。共有 4 种处理器支持的特权级别，分别是 0、 1、 2、 3，其中 0 是最高特权级别， 3 是最低特权级别。刚进入保护模式时执行的代码具有最高特权级 0(可以看成是从处理器那里继承来的)，这些代码通常都是操作系统代码(内核段)，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级(用户段)，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令(特权指令)只能由 0 特权级的程序来执行，为的就是安全。这里再次点明了为何叫保护模式。\n  S: 用于指定描述符的类型(Descriptor Type)。当该位是\u0026quot;0\u0026quot;时，表示是一个系统段；为\u0026quot;1\u0026quot;时，表示是一个代码段或者数据段(堆栈段也是特殊的数据段)。\n  TYPE: 共 4 位，用于指示描述符的子类型，或者说是类别。\n  描述符类型 对于数据段来说， 这 4 位分别是 X、 E、 W、 A 位；而对于代码段来说，这 4 位则分别是 X、 C、 R、 A 位。\n数据段  X: 表示是否可以执行（ eXecutable）。数据段总是不可执行的，X＝0。 E: 针对数据段。E 位指示段的扩展方向。 E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。 W: 段的读写属性，W＝0 的段是不允许写入的，否则会引发处理器异常中断； W＝1的段是可以正常写入的。 A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026rdquo;。  代码段   X: 表示是否可以执行(eXecutable)。代码段总是可以执行的 X＝1。\n  C: 是否为特权级依从的(Conforming)。 C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用； C＝1 表示允许从低特权级的程序转移到该段执行。\n  R: 是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由 R 位指定。 R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断；如果 R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。\n 也许有人会问，既然代码段是不可读的，那处理器怎么从里面取指令执行呢？事实上，这里的R属性并非用来限制处理器， 而是用来限制程序和指令的行为。\n   A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026rdquo;。\n  ","id":4,"section":"posts","summary":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。 GDTR寄存器存放G","tags":["操作系统"],"title":"GDT\u0026LDT","uri":"https://rx-78-kum0.github.io/2020/06/gdtldt/","year":"2020"},{"content":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support if runtime.GOOS == \u0026quot;windows\u0026quot; { return homeWindows() } // Unix-like system, so just assume Unix return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026quot;HOME\u0026quot;); home != \u0026quot;\u0026quot; { return home, nil } // If that fails, try the shell var stdout bytes.Buffer cmd := exec.Command(\u0026quot;sh\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;eval echo ~$USER\u0026quot;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026quot;\u0026quot;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026quot;\u0026quot; { return \u0026quot;\u0026quot;, errors.New(\u0026quot;blank output when reading home directory\u0026quot;) } return result, nil } func homeWindows() (string, error) { drive := os.Getenv(\u0026quot;HOMEDRIVE\u0026quot;) path := os.Getenv(\u0026quot;HOMEPATH\u0026quot;) home := drive + path if drive == \u0026quot;\u0026quot; || path == \u0026quot;\u0026quot; { home = os.Getenv(\u0026quot;USERPROFILE\u0026quot;) } if home == \u0026quot;\u0026quot; { return \u0026quot;\u0026quot;, errors.New(\u0026quot;HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\u0026quot;) } return home, nil }  ","id":5,"section":"posts","summary":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support if runtime.GOOS == \u0026quot;windows\u0026quot; { return homeWindows() } // Unix-like system, so just assume Unix return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026quot;HOME\u0026quot;); home != \u0026quot;\u0026quot; { return home, nil } // If that fails, try the","tags":["golang"],"title":"获取用户home目录路径","uri":"https://rx-78-kum0.github.io/2020/06/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/","year":"2020"},{"content":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2\n","id":6,"section":"posts","summary":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX 局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带","tags":["汇编"],"title":"变量和标签","uri":"https://rx-78-kum0.github.io/2020/06/%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E7%AD%BE/","year":"2020"},{"content":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm    emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install    添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib    最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install    Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls    拉取第三方依赖. (主要是rapidjson)\ngit submodule update --init --recursive    下载llvm的二进制包并解压\nwget -c http://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz    在根目录下执行cmake 执行结果保存到Release文件夹中\ncmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release    开始编译\ncd Release make -j4 #使用4线程编译    编译完成, 安装\nsudo make install    ","id":7,"section":"posts","summary":"Mac 首先需安装cmake和llvm brew install cmake llvm emacs里执行M-x irony-install-server得到安装执行命令 cmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config","tags":["emacs"],"title":"irony-server-install","uri":"https://rx-78-kum0.github.io/2020/05/irony-server-install/","year":"2020"},{"content":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.map keyboard: keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map  ","id":8,"section":"posts","summary":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. #","tags":["nasm"],"title":"bochsrc","uri":"https://rx-78-kum0.github.io/2020/05/bochsrc/","year":"2020"},{"content":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem  ","id":9,"section":"posts","summary":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem","tags":["汇编","mac"],"title":"mac编译nasm问题汇总","uri":"https://rx-78-kum0.github.io/2020/05/mac%E7%BC%96%E8%AF%91nasm%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","year":"2020"},{"content":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","id":10,"section":"posts","summary":"汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各","tags":["汇编"],"title":"汇编语言种类","uri":"https://rx-78-kum0.github.io/2020/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/","year":"2020"},{"content":"docker-compose 配置 version: '3' services: # mysql blog_mysql: image: mysql restart: always ports: - '3306:3306' environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - '/data/mysql:/var/lib/mysql'  docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash  登录mysql mysql -u root -p  修改root账号, 可以通过任何客户端连接 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'xxxxx';  ","id":11,"section":"posts","summary":"docker-compose 配置 version: '3' services: # mysql blog_mysql: image: mysql restart: always ports: - '3306:3306' environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - '/data/mysql:/var/lib/mysql' docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改ro","tags":["mysql","docker"],"title":"docker部署mysql问题汇总","uri":"https://rx-78-kum0.github.io/2020/05/docker%E9%83%A8%E7%BD%B2mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","year":"2020"},{"content":".flex { flex-shrink: 0; }  ","id":12,"section":"posts","summary":".flex { flex-shrink: 0; }","tags":["css"],"title":"flex宽度失效","uri":"https://rx-78-kum0.github.io/2020/04/flex%E5%AE%BD%E5%BA%A6%E5%A4%B1%E6%95%88/","year":"2020"},{"content":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);   img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","id":13,"section":"posts","summary":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的","tags":["web"],"title":"canvas-drawImage","uri":"https://rx-78-kum0.github.io/2020/03/canvas-drawimage/","year":"2020"},{"content":"#!/usr/bin/env bash # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e='\\033' RESET=\u0026quot;$e[0m\u0026quot; BOLD=\u0026quot;$e[1m\u0026quot; CYAN=\u0026quot;$e[0;96m\u0026quot; RED=\u0026quot;$e[0;91m\u0026quot; YELLOW=\u0026quot;$e[0;93m\u0026quot; GREEN=\u0026quot;$e[0;92m\u0026quot; echo if [ $[$RANDOM%2] -eq \u0026quot;0\u0026quot; ]; then echo -en $RED'`·.,¸,.·*·.' echo -e $RESET$BOLD'╭━━━━╮'$RESET echo -en $YELLOW'`·.,¸,.·*·.' echo -e $RESET$BOLD'|::: /\\_/\\\\'$RESET echo -en $GREEN'`·.,¸,.·*·.' echo -e $RESET$BOLD'|:::( ◕ᴥ◕)'$RESET echo -en $CYAN'`·.,¸,.·*·.' echo -e $RESET$BOLD'u-u━━-u--u'$RESET else echo -en $RED'-_-_-_-_-_-_-_' echo -e $RESET$BOLD',------,'$RESET echo -en $YELLOW'_-_-_-_-_-_-_-' echo -e $RESET$BOLD'| /\\_/\\\\'$RESET echo -en $GREEN'-_-_-_-_-_-_-' echo -e $RESET$BOLD'~|__( ^ .^)'$RESET echo -en $CYAN'-_-_-_-_-_-_-' echo -e $RESET$BOLD'\u0026quot;\u0026quot; \u0026quot;\u0026quot;'$RESET fi echo    ","id":14,"section":"posts","summary":"#!/usr/bin/env bash # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e='\\033' RESET=\u0026quot;$e[0m\u0026quot; BOLD=\u0026quot;$e[1m\u0026quot; CYAN=\u0026quot;$e[0;96m\u0026quot; RED=\u0026quot;$e[0;91m\u0026quot; YELLOW=\u0026quot;$e[0;93m\u0026quot; GREEN=\u0026quot;$e[0;92m\u0026quot; echo if [ $[$RANDOM%2] -eq \u0026quot;0\u0026quot; ]; then echo -en $RED'`·.,¸,.·*·.' echo -e $RESET$BOLD'╭━━━━╮'$RESET echo -en $YELLOW'`·.,¸,.·*·.' echo -e $RESET$BOLD'|::: /\\_/\\\\'$RESET echo -en $GREEN'`·.,¸,.·*·.' echo -e $RESET$BOLD'|:::( ◕ᴥ◕)'$RESET echo -en $CYAN'`·.,¸,.·*·.' echo -e $RESET$BOLD'u-u━━-u--u'$RESET else echo -en $RED'-_-_-_-_-_-_-_' echo -e $RESET$BOLD',------,'$RESET echo -en $YELLOW'_-_-_-_-_-_-_-' echo -e $RESET$BOLD'| /\\_/\\\\'$RESET echo -en $GREEN'-_-_-_-_-_-_-' echo -e $RESET$BOLD'~|__( ^ .","tags":["shell"],"title":"nyan","uri":"https://rx-78-kum0.github.io/2020/03/nyan/","year":"2020"},{"content":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则 return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位 L = char.charCodeAt(1); // 取出低位 code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法 return '\u0026amp;#' + code + ';'; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.replace(/\u0026amp;#(\\d+);/g, function(match, dec) { let H = Math.floor((dec - 0x10000) / 0x400) + 0xd800; let L = (Math.floor(dec - 0x10000) % 0x400) + 0xdc00; return String.fromCharCode(H, L); }); }  ","id":15,"section":"posts","summary":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则 return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位","tags":["web"],"title":"浏览器显示emoji","uri":"https://rx-78-kum0.github.io/2020/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAemoji/","year":"2020"},{"content":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026quot;fmt\u0026quot; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.age += 1 } func main() { // qcrao 是值类型 qcrao := Person{age: 18} // 值类型 调用接收者也是值类型的方法 fmt.Println(qcrao.howOld()) // 值类型 调用接收者是指针类型的方法 qcrao.growUp() fmt.Println(qcrao.howOld()) // ---------------------- // stefno 是指针类型 stefno := \u0026amp;Person{age: 100} // 指针类型 调用接收者是值类型的方法 fmt.Println(stefno.howOld()) // 指针类型 调用接收者也是指针类型的方法 stefno.growUp() fmt.Println(stefno.howOld()) }     - 值接收者 指针接收者     值类型调用者 方法会使用调用者的一个副本，类似于\u0026quot;传值\u0026rdquo; 使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (\u0026amp;qcrao).growUp()   指针类型调用者 指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld() 实际上也是\u0026quot;传值\u0026rdquo;, 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针    区别 如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.\n使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.\n 如果类型具备\u0026quot;原始的本质\u0026rdquo;, 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法. 像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法. 这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的. 如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法. 比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.  iface 和 eface 的区别 iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.\niface import \u0026quot;unsafe\u0026quot; type iface struct { tab *itab // 接口类型以及实际类型 data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储. } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type _type struct { // 类型大小 size uintptr ptrdata uintptr // 类型的 hash 值 hash uint32 // 类型的 flag，和反射相关 tflag tflag // 内存对齐相关 align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关 gcdata *byte str nameOff ptrToThis typeOff }    eface type eface struct { _type *_type data unsafe.Pointer }  _type _type 是描述 Go 语言中各种数据类型的结构体\ntype _type struct { // 类型大小 size uintptr ptrdata uintptr // 类型的 hash 值 hash uint32 // 类型的 flag，和反射相关 tflag tflag // 内存对齐相关 align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关 gcdata *byte str nameOff ptrToThis typeOff }  Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } type slicetype struct { typ _type elem *_type } type functype struct { typ _type inCount uint16 outCount uint16 } type ptrtype struct { typ _type elem *_type } type structfield struct { name name typ *_type offsetAnon uintptr }  这些数据类型的结构体定义, 是反射实现的基础.\n接口的动态类型和动态值 import \u0026quot;unsafe\u0026quot; type iface struct { tab *itab // 接口类型以及实际类型 data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 }  iface 类型包含两个字段:\n tab: 是接口表指针，指向类型信息 data: 是数据指针，则指向具体的数据  接口类型和 nil 作比较 接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 接口值 == nil.\n  package main import \u0026quot;fmt\u0026quot; func main() { var a interface{} fmt.Println(c == nil) // true var b *string fmt.Println(b == nil) // true a = b fmt.Println(a == nil) // false }  b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .\n  package main import \u0026quot;fmt\u0026quot; type MyError string func (i MyError) Error() string { return i } func main() { err := HandleError() fmt.Println(err == nil) // false } func HandleError() error { var err *MyError = nil return err }  调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .\n  打印接口的动态值和类型 package main import ( \u0026quot;unsafe\u0026quot; \u0026quot;fmt\u0026quot; ) type iface struct { itab, data uintptr } func main() { var a interface{} = nil var b interface{} = (*int)(nil) x := 5 var c interface{} = (*int)(\u0026amp;x) ia := *(*iface)(unsafe.Pointer(\u0026amp;a)) ib := *(*iface)(unsafe.Pointer(\u0026amp;b)) ic := *(*iface)(unsafe.Pointer(\u0026amp;c)) fmt.Println(ia) // {0 0} fmt.Println(ib) // {17426912 0} fmt.Println(ic) // {17426912 842350714568} fmt.Println(*(*int)(unsafe.Pointer(ic.data))) // 5 }   a 的动态类型和动态值的地址均为 0, 也就是 nil; b 的动态类型和 c 的动态类型一致, 都是 *int; c 的动态值为 5.  编译器自动检测类型是否实现接口 var _ io.Writer = (*myWriter)(nil)  编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.\npackage main import \u0026quot;io\u0026quot; type myWriter string func (w *myWriter) Write(p []byte) (n int, err error) { return } func main() { // 检查 *myWriter 类型是否实现了 io.Writer 接口 var _ io.Writer = (*myWriter)(nil) // 检查 myWriter 类型是否实现了 io.Writer 接口 var _ io.Writer = myWriter{} }  src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment: myWriter does not implement io.Writer (missing Write method)  myWriter 没用实现 io.Writer\n接口类型的赋值 (构造) 和断言 赋值 针对不同类型有以下函数:\n convT2E16, convT2I16 convT2E32, convT2I32 convT2E64, convT2I64 convT2Estring, convT2Istring convT2Eslice, convT2Islice convT2Enoptr, convT2Inoptr\n func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return }  把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.\n断言 func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value. panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026quot;\u0026quot;}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertE2I(inter *interfacetype, e eface) (r iface) { t := e._type if t == nil { // explicit conversions require non-nil interface value. panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026quot;\u0026quot;}) } r.tab = getitab(inter, t, false) r.data = e.data return } func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) { t := e._type if t == nil { return } tab := getitab(inter, t, true) if tab == nil { return } r.tab = tab r.data = e.data b = true return }  判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).\nassertI2I 对应 接口断言返回一个参数:\npackage main import ( \u0026quot;errors\u0026quot; \u0026quot;fmt\u0026quot; ) func main(args) { var a interface{} = errors.New(\u0026quot;error\u0026quot;) err := a.(error) fmt.Println(err.Error()) }  assertI2I2 则对应返回两个参数的情况:\npackage main import ( \u0026quot;errors\u0026quot; \u0026quot;fmt\u0026quot; ) func main(args) { var a interface{} = errors.New(\u0026quot;error\u0026quot;) if err, ok := a.(error); ok { fmt.Println(err.Error()) } }  都在编译阶段编译器判断.\n打印接口类型的hash值 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;unsafe\u0026quot; ) type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter uintptr _type uintptr hash uint32 _ [4]byte fun [1]uintptr } func main() { p := Person(Student{age: 18}) iface := (*iface)(unsafe.Pointer(\u0026amp;p)) fmt.Printf(\u0026quot;iface.tab.hash = %#x\\n\u0026quot;, iface.tab.hash) // iface.tab.hash = 0xd4209fda }  类型转换和断言的区别 类型转换 Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量. 类型转换前后的两个类型必须相互兼容.\n \u0026lt;结果类型\u0026gt; := \u0026lt;目标类型\u0026gt; ( \u0026lt;表达式\u0026gt; )\n package main import \u0026quot;fmt\u0026quot; func main() { var i int = 9 var f float64 f = float64(i) fmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, f, f) f = 10.8 a := int(f) fmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, a, a) // s := []int(i) }  断言 空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口. 当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.\n \u0026lt;目标类型的值\u0026gt;，\u0026lt;布尔参数\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 ) // 安全类型断言 \u0026lt;目标类型的值\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 )　//非安全类型断言\n package main import \u0026quot;fmt\u0026quot; type Student struct { Name string Age int } func main() { var i interface{} = new(Student) s := i.(*Student) fmt.Println(s) }  switch 形式断言\npackage main import \u0026quot;fmt\u0026quot; type Student struct { Name string Age int } func main() { var i interface{} judge(i) } func judge(v interface{}) { fmt.Printf(\u0026quot;%p %v\\n\u0026quot;, \u0026amp;v, v) switch v := v.(type) { case nil: fmt.Printf(\u0026quot;%p %v\\n\u0026quot;, \u0026amp;v, v) fmt.Printf(\u0026quot;nil type[%T] %v\\n\u0026quot;, v, v) case Student: fmt.Printf(\u0026quot;%p %v\\n\u0026quot;, \u0026amp;v, v) fmt.Printf(\u0026quot;Student type[%T] %v\\n\u0026quot;, v, v) case *Student: fmt.Printf(\u0026quot;%p %v\\n\u0026quot;, \u0026amp;v, v) fmt.Printf(\u0026quot;*Student type[%T] %v\\n\u0026quot;, v, v) default: fmt.Printf(\u0026quot;%p %v\\n\u0026quot;, \u0026amp;v, v) fmt.Printf(\u0026quot;unknow\\n\u0026quot;) } }  fmt.Println 函数 fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印. 而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.\n因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:\npackage main import \u0026quot;fmt\u0026quot; type Student struct { Name string Age int } func main() { s := Student{ Name: \u0026quot;zzz\u0026quot;, Age: 18, } fmt.Println(s) // {zzz 18} }  增加一个 String() 方法的实现:\nimport \u0026quot;fmt\u0026quot; func (s Student) String() string { return fmt.Sprintf(\u0026quot;[Name: %s], [Age: %d]\u0026quot;, s.Name, s.Age) // [Name: zzz], [Age: 18] }  修改 String() 方法:\nimport \u0026quot;fmt\u0026quot; func (s *Student) String() string { return fmt.Sprintf(\u0026quot;[Name: %s], [Age: %d]\u0026quot;, s.Name, s.Age) // {zzz 18} }  打印结果并没用调用 String() ,因为:\n 类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.\n 要调用 String() 需要:\nfmt.Println(\u0026amp;s)  接口转换的原理 类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).\npackage main import \u0026quot;fmt\u0026quot; type coder interface { code() run() } type runner interface { run() } type Gopher struct { language string } func (g Gopher) code() { return } func (g Gopher) run() { return } func main() { var c coder = Gopher{} var r runner r = c fmt.Println(c, r) }  Gopher 类型同时满足 coder 接口和 runner 接口.\nconvI2I 函数将一个 interface 转换成 另一个 interface .\nfunc convI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return }  inter 表示要转成的接口类型, i 表示一个实体类型. 如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.\nimport \u0026quot;unsafe\u0026quot; func getitab(inter *interfacetype, typ *_type, canfail bool) *itab { if len(inter.mhdr) == 0 { throw(\u0026quot;internal error - misuse of itab\u0026quot;) } // easy case if typ.tflag\u0026amp;tflagUncommon == 0 { if canfail { return nil } name := inter.typ.nameOff(inter.mhdr[0].name) panic(\u0026amp;TypeAssertionError{nil, typ, \u0026amp;inter.typ, name.name()}) } var m *itab // First, look in the existing table to see if we can find the itab we need. // This is by far the most common case, so do it without locks. // Use atomic to ensure we see any previous writes done by the thread // that updates the itabTable field (with atomic.Storep in itabAdd). t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026amp;itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // Not found. Grab the lock and try again. lock(\u0026amp;itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026amp;itabLock) goto finish } // Entry doesn't exist yet. Make a new entry \u0026amp; add it. m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026amp;memstats.other_sys)) m.inter = inter m._type = typ // The hash is used in type switches. However, compiler statically generates itab's // for all interface/type pairs used in switches (which are added to itabTable // in itabsinit). The dynamically-generated itab's never participate in type switches, // and thus the hash is irrelevant. // Note: m.hash is _not_ the hash used for the runtime itabTable hash table. m.hash = 0 m.init() itabAdd(m) unlock(\u0026amp;itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } // this can only happen if the conversion // was already done once using the , ok form // and we have a cached negative result. // The cached result doesn't record which // interface function was missing, so initialize // the itab again to get the missing function name. panic(\u0026amp;TypeAssertionError{concrete: typ, asserted: \u0026amp;inter.typ, missingMethod: m.init()}) }  getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.\n这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁. 这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.\nitabAdd 函数会把 itab 写入到全局itabTable\nimport \u0026quot;unsafe\u0026quot; func itabAdd(m *itab) { // Bugs can lead to calling this while mallocing is set, // typically because this is called while panicing. // Crash reliably, rather than only when we need to grow // the hash table. if getg().m.mallocing != 0 { throw(\u0026quot;malloc deadlock\u0026quot;) } t := itabTable if t.count \u0026gt;= 3*(t.size/4) { // 75% load factor // Grow hash table. // t2 = new(itabTableType) + some additional entries // We lie and tell malloc we want pointer-free memory because // all the pointed-to values are not in the heap. t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 // Copy over entries. // Note: while copying, other threads may look for an itab and // fail to find it. That's ok, they will then try to get the itab lock // and as a consequence wait until this copying is complete. iterate_itabs(t2.add) if t2.count != t.count { throw(\u0026quot;mismatched count during itab table copy\u0026quot;) } // Publish new hash table. Use an atomic write: see comment in getitab. atomicstorep(unsafe.Pointer(\u0026amp;itabTable), unsafe.Pointer(t2)) // Adopt the new table as our own. t = itabTable // Note: the old table can be GC'ed here. } t.add(m) } func iterate_itabs(fn func(*itab)) { // Note: only runs during stop the world or with itabLock held, // so no other locks/atomics needed. t := itabTable for i := uintptr(0); i \u0026lt; t.size; i++ { m := *(**itab)(add(unsafe.Pointer(\u0026amp;t.entries), i*sys.PtrSize)) if m != nil { fn(m) } } }  如何用 interface 实现多态 多态是一种运行期的行为, 它有以下几个特点:\n 一种类型具有多种类型的能力 允许不同的对象对同一消息做出灵活的反应 以一种通用的方式对待个使用的对象 非动态语言必须通过继承和接口的方式来实现   package main import \u0026quot;fmt\u0026quot; func main() { s := Student{age: 18} whatJob(\u0026amp;s) growUp(\u0026amp;s) fmt.Println(s) p := Programmer{age: 100} whatJob(p) growUp(p) fmt.Println(p) } func whatJob(p Person) { p.job() } func growUp(p Person) { p.growUp() } type Person interface { job() growUp() } type Student struct { age int } func (p Student) job() { fmt.Println(\u0026quot;I am a student.\u0026quot;) return } func (p *Student) growUp() { p.age += 1 return } type Programmer struct { age int } func (p Programmer) job() { fmt.Println(\u0026quot;I am a programmer.\u0026quot;) return } func (p Programmer) growUp() { p.age += 10 return }  Go 接口与 C++ 接口有何异同 接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.\nC++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类. 纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的. 例如:\nclass Shape { public: // 纯虚函数 virtual double getArea() = 0; private: string name; // 名称 };   设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用. 派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.\nC++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.\nC++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数; 而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的. 原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响; 这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.\n ","id":16,"section":"posts","summary":"Go 语言与鸭子类型的关系 If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是","tags":["golang"],"title":"interface类型","uri":"https://rx-78-kum0.github.io/2020/03/interface%E7%B1%BB%E5%9E%8B/","year":"2020"},{"content":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }  ","id":17,"section":"posts","summary":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }","tags":["css"],"title":"文字超出显示省略号","uri":"https://rx-78-kum0.github.io/2020/03/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/","year":"2020"},{"content":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB *stack = malloc(); // 创建栈 *stack = A; // 保存栈 tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.esp; // esp: CPU寄存器 // jmp xxx; // 不需要再jmp xxx, 因为调用Yield时已经把Yield后面执行的内容压栈. }  缺点 一个进程里的某个用户级线程触发系统IO(如网卡, 磁盘等)后系统会切换到其他进程执行. 这个进程其他线程就无法执行.\n核心级线程 多\u0026quot;套\u0026rdquo;(用户栈 + 内核栈)TCB在内核中. 中断进入内核\n优点 多核心CPU支持, 核心级线程可以并行执行.\n","id":18,"section":"posts","summary":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变. 价值, 用处 浏览器 一个线程用来从服务器接收数据 一个线程","tags":["操作系统"],"title":"多线程","uri":"https://rx-78-kum0.github.io/2020/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","year":"2020"},{"content":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026raquo; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换\nvoid schedule() { pNew = getNext(ReadyQueue); // 调度 switch_to(pCur, pNew); // pCur, pNew PCB }  把当前进程保存起来, 切入另一个的进程.\nvoid swtich_to(pCur, pNew) { pCur.ax = CPU.ax; pCur.bx = CPU.bx; // ... pCur.cs = CPU.cs; pCur.retpc = CPU.pc; CPU.ax = pNew.ax; CPU.bx = pNew.bx; // ... CPU.cs = pNew.cs; CPU.pc = pNew.retpc; }  多进程的内存管理 通过映射表实现内存地址空间的分离.\n进程1 内存地址[100] \u0026mdash;\u0026gt; 进程1的映射表 \u0026mdash;-\u0026gt; 物理内存 780 进程2 内存地址[100] \u0026mdash;\u0026gt; 进程2的映射表 \u0026mdash;-\u0026gt; 物理内存 1260\n多进程的合作 生产者与消费者 进程同步不能随意切换进程, 必须同步进程合理切换.\n","id":19,"section":"posts","summary":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在","tags":["操作系统"],"title":"多进程","uri":"https://rx-78-kum0.github.io/2020/02/%E5%A4%9A%E8%BF%9B%E7%A8%8B/","year":"2020"},{"content":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, ...b: T extends any[] ? T : never) =\u0026gt; void) extends (...a: infer R) =\u0026gt; void ? R : never; type Push\u0026lt;T, A\u0026gt; = Copy\u0026lt;Unshift\u0026lt;T, any\u0026gt;, T \u0026amp; Record\u0026lt;string, A\u0026gt;\u0026gt;; // 搜索二进制 trie type SearchInTrie\u0026lt;Num, Node, Digits\u0026gt; = { 1: Node extends [infer A, infer B] ? Num extends A ? Push\u0026lt;Digits, 0\u0026gt; : Num extends B ? Push\u0026lt;Digits, 1\u0026gt; : never : never; 0: Node extends [infer A, infer B] ? SearchInTrie\u0026lt;Num, A, Push\u0026lt;Digits, 0\u0026gt;\u0026gt; | SearchInTrie\u0026lt;Num, B, Push\u0026lt;Digits, 1\u0026gt;\u0026gt; : never; }[Node extends [number, number] ? 1 : 0]; // 定义数字类型 type Digit = 0 | 1; type Bits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7; type Uint8 = Record\u0026lt;Bits, Digit\u0026gt;; // 也可以定义成8个Digit的数组，这样写比较简短 type AsDigit\u0026lt;T\u0026gt; = T extends Digit ? T : never; type AsUint8\u0026lt;T\u0026gt; = T extends Uint8 ? T : never; // 数字转二进制表示 type ToUint8\u0026lt;A extends number\u0026gt; = SearchInTrie\u0026lt;A, BinaryTrie, []\u0026gt;; // 二进制表示转数字 type ToNumber\u0026lt;A extends Uint8\u0026gt; = BinaryTrie[A[0]][A[1]][A[2]][A[3]][A[4]][A[5]][A[6]][A[7]]; // 两个1 bit数相加，C 表示进位 type BitAdd\u0026lt;A extends Digit, B extends Digit, C extends Digit\u0026gt; = [ [[[0, 0], [1, 0]], [[1, 0], [0, 1]]], [[[1, 0], [0, 1]], [[0, 1], [1, 1]]] ][A][B][C]; // 8位数相加 type Uint8Add\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitAdd\u0026lt;A[7], B[7], 0\u0026gt; extends [infer S7, infer C] ? BitAdd\u0026lt;A[6], B[6], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S6, infer C] ? BitAdd\u0026lt;A[5], B[5], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S5, infer C] ? BitAdd\u0026lt;A[4], B[4], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S4, infer C] ? BitAdd\u0026lt;A[3], B[3], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S3, infer C] ? BitAdd\u0026lt;A[2], B[2], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S2, infer C] ? BitAdd\u0026lt;A[1], B[1], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S1, infer C] ? BitAdd\u0026lt;A[0], B[0], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S0, infer C] // ? C extends 1 ? \u0026quot;overflow\u0026quot; : ? AsUint8\u0026lt;[S0, S1, S2, S3, S4, S5, S6, S7]\u0026gt; : never : never : never : never : never : never : never : never; // 位取反 type Reverse = [1, 0]; type Uint8Reverse\u0026lt;A extends Uint8\u0026gt; = [ Reverse[A[0]], Reverse[A[1]], Reverse[A[2]], Reverse[A[3]], Reverse[A[4]], Reverse[A[5]], Reverse[A[6]], Reverse[A[7]] ]; // 两个特殊数字方便使用 type ZERO = [0, 0, 0, 0, 0, 0, 0, 0]; type ONE = [0, 0, 0, 0, 0, 0, 0, 1]; // 补码 type Uint8Negate\u0026lt;A extends Uint8\u0026gt; = Uint8Add\u0026lt;Uint8Reverse\u0026lt;A\u0026gt;, ONE\u0026gt;; // 8位数相减 type Uint8Sub\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;A, Uint8Negate\u0026lt;B\u0026gt;\u0026gt;; // 左移 type LShift\u0026lt;A extends Uint8, B extends number, P extends Digit\u0026gt; = B extends 1 ? [A[1], A[2], A[3], A[4], A[5], A[6], A[7], P] : B extends 2 ? [A[2], A[3], A[4], A[5], A[6], A[7], P, P] : B extends 3 ? [A[3], A[4], A[5], A[6], A[7], P, P, P] : B extends 4 ? [A[4], A[5], A[6], A[7], P, P, P, P] : B extends 5 ? [A[5], A[6], A[7], P, P, P, P, P] : B extends 6 ? [A[6], A[7], P, P, P, P, P, P] : B extends 7 ? [A[7], P, P, P, P, P, P, P] : B extends 0 ? A : [P, P, P, P, P, P, P, P]; // 8位数乘1位数 type BitMul\u0026lt;A extends Uint8, B extends Digit, C extends Bits\u0026gt; = B extends 1 ? LShift\u0026lt;A, C, 0\u0026gt; : ZERO; // 8位数相乘 type Uint8Mul\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;ZERO, BitMul\u0026lt;A, B[7], 0\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[6], 1\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[5], 2\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[4], 3\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[3], 4\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[2], 5\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[1], 6\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[0], 7\u0026gt;\u0026gt; : never : never : never : never : never : never : never; // 比较结果 type EQ = 0; type GT = 1; type LT = 2; // 1位数比较 type BitCMP\u0026lt;A extends Digit, B extends Digit\u0026gt; = [[EQ, LT], [GT, EQ]][A][B]; // 8位数比较 type Uint8CMP\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitCMP\u0026lt;A[0], B[0]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[0], B[0]\u0026gt; : BitCMP\u0026lt;A[1], B[1]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[1], B[1]\u0026gt; : BitCMP\u0026lt;A[2], B[2]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[2], B[2]\u0026gt; : BitCMP\u0026lt;A[3], B[3]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[3], B[3]\u0026gt; : BitCMP\u0026lt;A[4], B[4]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[4], B[4]\u0026gt; : BitCMP\u0026lt;A[5], B[5]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[5], B[5]\u0026gt; : BitCMP\u0026lt;A[6], B[6]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[6], B[6]\u0026gt; : BitCMP\u0026lt;A[7], B[7]\u0026gt;; // 简单求余 type Remainder\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8CMP\u0026lt;A, B\u0026gt; extends LT ? [0, A] : [1, Uint8Sub\u0026lt;A, B\u0026gt;]; // 8位数相除 type Uint8Div\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Remainder\u0026lt;LShift\u0026lt;ZERO, 1, A[0]\u0026gt;, B\u0026gt; extends [infer Q0, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[1]\u0026gt;, B\u0026gt; extends [infer Q1, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[2]\u0026gt;, B\u0026gt; extends [infer Q2, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[3]\u0026gt;, B\u0026gt; extends [infer Q3, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[4]\u0026gt;, B\u0026gt; extends [infer Q4, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[5]\u0026gt;, B\u0026gt; extends [infer Q5, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[6]\u0026gt;, B\u0026gt; extends [infer Q6, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[7]\u0026gt;, B\u0026gt; extends [infer Q7, infer R] ? [AsUint8\u0026lt;[Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7]\u0026gt;, AsUint8\u0026lt;R\u0026gt;] : never : never : never : never : never : never : never : never; // 加 type Add\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Add\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 减 type Sub\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Sub\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 乘 type Mul\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Mul\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 除 type Div\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[0]\u0026gt;; // 取余 type Mod\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[1]\u0026gt;; // 测试 type case1_ShouldBe99 = Add\u0026lt;33, 66\u0026gt;; // 33 + 66 = 99 type case2_ShouldBe0 = Add\u0026lt;255, 1\u0026gt;; // 255 + 1 = 0 (overflow) const a: case1_ShouldBe99 = 99; type case3_ShouldBe99 = Sub\u0026lt;123, 24\u0026gt;; // 123 - 24 = 99 type case4_ShouldBe255 = Sub\u0026lt;0, 1\u0026gt;; // 0 - 1 = 255 (overflow) type case5_ShouldBe153 = Mul\u0026lt;17, 9\u0026gt;; // 17 x 9 = 153 type case6_ShouldBe253 = Mul\u0026lt;255, 3\u0026gt;; // 255 x 3 = 253 (overflow) type case7_ShouldBe33 = Div\u0026lt;100, 3\u0026gt;; // 100 / 3 = 33 type case8_ShouldBeNever = Div\u0026lt;1, 0\u0026gt;; // 1 / 0 = error (divide by 0) type case9_ShouldBe1 = Mod\u0026lt;100, 3\u0026gt;; // 100 % 3 = 1 type case10_ShouldBeNever = Mod\u0026lt;1, 0\u0026gt;; // 1 % 0 = error (divide by 0)  ","id":20,"section":"posts","summary":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50,","tags":["typescript"],"title":"typescript元编程","uri":"https://rx-78-kum0.github.io/2020/02/typescript%E5%85%83%E7%BC%96%E7%A8%8B/","year":"2020"},{"content":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom  ","id":21,"section":"posts","summary":"# .clang-format BasedOnStyle: LLVM Language: Cpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket: Align # 大括号换行，只有当","tags":["tools"],"title":"clang-format","uri":"https://rx-78-kum0.github.io/2020/02/clang-format/","year":"2020"},{"content":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！  Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。\n Hugo的优点 - 快 基于 golang 编写的\n- 简单 不仅使用简单，甚至自己写主题也很简单。\n- 支持org格式! (优秀) hexo, jekyll 等同类工具大多只支持 markdown. 而 hugo 支持 org 这一仅在 emacs 上有的文档格式，感动~\n 但不会直接用org来发布~ 目前支持程度远没有 markdown 格式好。因为 org 在 emacs 上原生支持太好，又不像 md 这样通用导致其他平台支持程度不是很高。好在可以使用 emacs 插件把 org 转成 md，虽然还是会丢失一些 org 的特性。\n Org -\u0026gt; Markdown Emacs 的 ox-hugo\n安装 (use-package ox-hugo :after ox)  使用    需要在org文档元数据上标明hugo博客的根目录 HUGO_BASE_DIR 和生成文档的目标目录 HUGO_SECTION\n#+HUGO_BASE_DIR: ~/Hugo-DirName #+HUGO_SECTION: posts       C-c C-e H h\n导出当前org文档\n     org-hugo-auto-export-mode\n保存org文档自动导出为md\n在hugo博客根目录添加.dir-locals.el文件:\n((\u0026quot;content-org/\u0026quot; . ((org-mode . ((eval . (org-hugo-auto-export-mode)))))))  最终Hugo目录树:\n\u0026lt;HUGO_BASE_DIR\u0026gt; ├── config.toml ├── content ├── \u0026lt;HUGO_SECTION\u0026gt; ├── content-org \u0026lt;-- Org files in there ├── static ├── themes └── .dir-locals.el    ","id":22,"section":"posts","summary":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！ Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。 Hugo的优点 - 快 基于 golang 编写的 - 简单","tags":["helloworld"],"title":"Hello_World","uri":"https://rx-78-kum0.github.io/2020/01/hello_world/","year":"2020"},{"content":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can't be split into multiple # lines. End of line (return) is considered as the end of the statement. multi_line = True # Destructive warning mode will alert you before executing a sql statement # that may cause harm to the database such as \u0026quot;drop table\u0026quot;, \u0026quot;drop database\u0026quot; # or \u0026quot;shutdown\u0026quot;. destructive_warning = True # log_file location. log_file = ~/.mycli.log # Default log level. Possible values: \u0026quot;CRITICAL\u0026quot;, \u0026quot;ERROR\u0026quot;, \u0026quot;WARNING\u0026quot;, \u0026quot;INFO\u0026quot; # and \u0026quot;DEBUG\u0026quot;. \u0026quot;NONE\u0026quot; disables logging. log_level = INFO # Log every query and its results to a file. Enable this by uncommenting the # line below. # audit_log = ~/.mycli-audit.log # Timing of sql statments and table rendering. timing = True # Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe, # orgtbl, rst, mediawiki, html, latex, latex_booktabs, tsv. # Recommended: psql, fancy_grid and grid. table_format = psql # Syntax coloring style. Possible values (many support the \u0026quot;-dark\u0026quot; suffix): # manni, igor, xcode, vim, autumn, vs, rrt, native, perldoc, borland, tango, emacs, # friendly, monokai, paraiso, colorful, murphy, bw, pastie, paraiso, trac, default, # fruity. # Screenshots at http://mycli.net/syntax syntax_style = default # Keybindings: Possible values: emacs, vi. # Emacs mode: Ctrl-A is home, Ctrl-E is end. All emacs keybindings are available in the REPL. # When Vi mode is enabled you can use modal editing features offered by Vi in the REPL. key_bindings = emacs # Enabling this option will show the suggestions in a wider menu. Thus more items are suggested. wider_completion_menu = False # MySQL prompt # \\t - Product type (Percona, MySQL, Mariadb) # \\u - Username # \\h - Hostname of the server # \\d - Database name # \\n - Newline prompt = '\\t \\u@\\h:\\d\u0026gt; ' prompt_continuation = '-\u0026gt; ' # Skip intro info on startup and outro info on exit less_chatty = False # Use alias from --login-path instead of host name in prompt login_path_as_host = False # Custom colors for the completion menu, toolbar, etc. [colors] # Completion menus. Token.Menu.Completions.Completion.Current = 'bg:#00aaaa #000000' Token.Menu.Completions.Completion = 'bg:#008888 #ffffff' Token.Menu.Completions.MultiColumnMeta = 'bg:#aaffff #000000' Token.Menu.Completions.ProgressButton = 'bg:#003333' Token.Menu.Completions.ProgressBar = 'bg:#00aaaa' # Selected text. Token.SelectedText = '#ffffff bg:#6666aa' # Search matches. (reverse-i-search) Token.SearchMatch = '#ffffff bg:#4444aa' Token.SearchMatch.Current = '#ffffff bg:#44aa44' # The bottom toolbar. Token.Toolbar = 'bg:#222222 #aaaaaa' Token.Toolbar.Off = 'bg:#222222 #888888' Token.Toolbar.On = 'bg:#222222 #ffffff' # Search/arg/system toolbars. Token.Toolbar.Search = 'noinherit bold' Token.Toolbar.Search.Text = 'nobold' Token.Toolbar.System = 'noinherit bold' Token.Toolbar.Arg = 'noinherit bold' Token.Toolbar.Arg.Text = 'nobold' # Favorite queries. [favorite_queries]  ","id":23,"section":"posts","summary":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can't be split into multiple # lines.","tags":["mysql","tools"],"title":"myclirc","uri":"https://rx-78-kum0.github.io/2019/12/myclirc/","year":"2019"},{"content":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n.org-center { margin-left: auto; margin-right: auto; text-align: center; }  使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n 毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; }  writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, 'value', value); }  registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; }  registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this._onTouched = fn; }  setDisabledState?(isDisabled: boolean): 该方法是组件输入状态 disable \u0026lt;=\u0026gt; enable 变化时的回调。该方法会根据参数值，启用或禁用指定的DOM元素.\n以下组件类实现了ControlValueAccessor接口. CheckboxControlValueAccessor 用于checkbox复选组件选择器:\n input[type=checkbox][formControlName] input[type=checkbox][formControl] input[type=checkbox][ngModel]  NumberValueAccessor 用于number类型的输入组件选择器:\n input[type=number][formControlName] input[type=number][formControl] input[type=number][ngModel]  DefaultValueAccessor 用于 text 和 textarea 类型的输入组件选择器:\n input:not([type=checkbox])[formControlName] textarea[formControlName] input:not([type=checkbox])[formControl] textarea[formControl] input:not([type=checkbox])[ngModel] textarea[ngModel] [ngDefaultControl]  RadioControlValueAccessor 用于radio单选组件选择器:\n input[type=radio][formControlName] input[type=radio][formControl] input[type=radio][ngModel]  扩展方法:\n fireUncheck(value: any): void:取消选中的回调.  RangeValueAccessor 用于范围输入组件选择器:\n input[type=range][formControlName] input[type=range][formControl] input[type=range][ngModel]  SelectControlValueAccessor 用于select组件选择器:\n select:not([multiple])[formControlName] select:not([multiple])[formControl] select:not([multiple])[ngModel]  扩展方法:\n compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时,需要编写一个比较函数来处理当前选中的对象是哪一个option.  SelectMultipleControlValueAccessor 用于多选select组件选择器:\n select[multiple][formControlName] select[multiple][formControl] select[multiple][ngModel]  扩展方法: compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时, 需要编写一个比较函数来处理当前选中的对象是哪一个option.\nEG 自定义表单组件代码结构 import { Component, OnInit, HostListener, ViewEncapsulation, forwardRef, Input, OnDestroy, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms'; import { Subject } from 'rxjs'; @Component({ selector : '[app-radiobox]', templateUrl : './radiobox.component.html', styleUrls : ['./radiobox.component.styl'], encapsulation : ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host : { '[class.radio-wrapper]' : 'true', '[class.radio-wrapper-checked]': 'checked' }, providers: [ { provide : NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u0026gt; RadioboxComponent), multi : true } ] }) export class RadioboxComponent implements OnInit, OnDestroy, ControlValueAccessor { @Input() value: boolean; checked: boolean; select$ = new Subject\u0026lt;RadioboxComponent\u0026gt;(); onChange: (_: any) =\u0026gt; void = () =\u0026gt; null; onTouched: () =\u0026gt; void = () =\u0026gt; null; constructor(private _cdr: ChangeDetectorRef) {} @HostListener('click', ['$event']) onClick(e: MouseEvent): void { e.stopPropagation(); e.preventDefault(); this.checked = !this.checked; this.onChange(this.checked); this.select$.next(this); } writeValue(value: boolean) { this.checked = value; } registerOnChange(fn: (_: boolean) =\u0026gt; {}): void { this.onChange = fn; } registerOnTouched(fn: () =\u0026gt; {}): void { this.onTouched = fn; } ngOnInit() {} ngOnDestroy() {} }  调用 import { Component, OnInit } from '@angular/core'; import { FormBuilder, FormGroup } from '@angular/forms'; @Component({ selector: 'app-example', template: ` \u0026lt;form [formGroup]=\u0026quot;testForm\u0026quot;\u0026gt; \u0026lt;label\u0026gt;试试\u0026lt;/label\u0026gt; \u0026lt;label app-radiobox formControlName=\u0026quot;check\u0026quot;\u0026gt;check me\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; ` }) export class ExampleComponent implements OnInit { testForm: FormGroup = this._fb.group({ check: false }); constructor(private _fb: FormBuilder) {} ngOnInit() { this.testForm.valueChanges.subscribe(d =\u0026gt; { console.log(d); }); } }  ","id":24,"section":"posts","summary":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口 .org-center { margin-left: auto; margin-right: auto; text-align: center; } 使自定义表单组件像原生i","tags":["angular"],"title":"angular自定义双向绑定表单组件","uri":"https://rx-78-kum0.github.io/2019/07/angular%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","year":"2019"},{"content":"\u0026quot; .vimrc \u0026quot; Configuration file for vim set modelines=0 \u0026quot; Don't write backup file if vim is being called by \u0026quot;crontab -e\u0026quot; \u0026quot; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026quot; Don't write backup file if vim is being called by \u0026quot;chpass\u0026quot; \u0026quot; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026quot; \u0026lt;leader\u0026gt; let g:mapleader=\u0026quot;,\u0026quot; \u0026quot; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026quot; 设置退格键可用 set backspace=2 \u0026quot; utf-8 set encoding=UTF-8 \u0026quot; 主题 \u0026quot; set background=dark \u0026quot; colorscheme dracula \u0026quot; 函数方法名加粗 let g:enable_bold_font = 1 \u0026quot; 注释斜体 let g:enable_italic_font = 1 \u0026quot; 透明背景 let g:hybrid_transparent_background = 1 \u0026quot; airline_theme let g:airline_theme = \u0026quot;hybrid\u0026quot; \u0026quot; 行号 set nu! \u0026quot; 高亮显示寻找匹配 set hls \u0026quot; 允许用指定语法高亮配色方案替换默认方案 syntax on dracula \u0026quot; 开启语法高亮 syntax enable \u0026quot; 设置匹配模式 (当输入一个左括号时会匹配相应的右括号) set showmatch \u0026quot; 显示当前光标位置 set ruler \u0026quot; 使用系统剪切板 set clipboard=unnamed \u0026quot; 设置格式化时代码缩进为2个空格 set shiftwidth=2 \u0026quot; tab键缩进为4格子 set tabstop=2 \u0026quot; 把连续数量的空格视为一个制表符 set softtabstop=2 \u0026quot; 禁止折行 set nowrap \u0026quot; tab键转换为空格 set expandtab \u0026quot; 智能缩进 set smartindent \u0026quot; 开启实时搜索功能 set incsearch \u0026quot; 搜索时大小写不敏感 set ignorecase \u0026quot; vim 自身命令行模式智能补全 set wildmenu \u0026quot; 开启文件类型侦测 filetype on \u0026quot; 根据侦测到的不同类型加载对应的插件 filetype plugin on \u0026quot; 自适应不同语言的智能缩进 filetype indent on \u0026quot; 将制表符扩展为空格 set nofoldenable \u0026quot; 基于缩进或语法进行代码折叠 set foldmethod=syntax \u0026quot; 启动 vim 时关闭折叠代码 set nofoldenable \u0026quot; 禁止光标闪烁 set gcr=a:block-blinkon0 \u0026quot; 禁止显示滚动条 set guioptions-=l set guioptions-=L set guioptions-=r set guioptions-=R \u0026quot; 高亮显示当前行/列 set cursorline set cursorcolumn \u0026quot; 让配置变更立即生效 autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026quot; normal 模式 keymap nnoremap x \u0026quot;_x nnoremap X \u0026quot;_X nnoremap d \u0026quot;_d nnoremap dd \u0026quot;_dd nnoremap D \u0026quot;_D nnoremap s \u0026quot;_s nnoremap S \u0026quot;_S nnoremap c \u0026quot;_c nnoremap C \u0026quot;_C \u0026quot; insert 模式 inoremap $( ()\u0026lt;esc\u0026gt;i inoremap $\u0026lt; \u0026lt;\u0026gt;\u0026lt;esc\u0026gt;i inoremap ${ {}\u0026lt;esc\u0026gt;i inoremap $[ []\u0026lt;esc\u0026gt;i inoremap $' ''\u0026lt;esc\u0026gt;i inoremap $\u0026quot; \u0026quot;\u0026quot;\u0026lt;esc\u0026gt;i \u0026quot; visual 模式 vnoremap s \u0026quot;_s vnoremap S \u0026quot;_S vnoremap z) c()\u0026lt;esc\u0026gt;hp vnoremap z} c{}\u0026lt;esc\u0026gt;hp vnoremap z] c[]\u0026lt;esc\u0026gt;hp vnoremap z' c''\u0026lt;esc\u0026gt;hp vnoremap z\u0026quot; c\u0026quot;\u0026quot;\u0026lt;esc\u0026gt;hp vnoremap z\u0026gt; c\u0026lt;\u0026gt;\u0026lt;esc\u0026gt;hp vnoremap z` c``\u0026lt;esc\u0026gt;hp \u0026quot; NERDTree let g:NERDTreeIndicatorMapCustom = { \\ \u0026quot;Modified\u0026quot; : \u0026quot;✹\u0026quot;, \\ \u0026quot;Staged\u0026quot; : \u0026quot;✚\u0026quot;, \\ \u0026quot;Untracked\u0026quot; : \u0026quot;✭\u0026quot;, \\ \u0026quot;Renamed\u0026quot; : \u0026quot;➜\u0026quot;, \\ \u0026quot;Unmerged\u0026quot; : \u0026quot;═\u0026quot;, \\ \u0026quot;Deleted\u0026quot; : \u0026quot;✖\u0026quot;, \\ \u0026quot;Dirty\u0026quot; : \u0026quot;✗\u0026quot;, \\ \u0026quot;Clean\u0026quot; : \u0026quot;✔︎\u0026quot;, \\ \u0026quot;Unknown\u0026quot; : \u0026quot;?\u0026quot; \\ } \u0026quot; 自动开启NERDTree \u0026quot; autocmd vimenter * NERDTree \u0026quot; UltiSnips let g:UltiSnipsExpandTrigger=\u0026quot;\u0026lt;Leader\u0026gt;\u0026lt;TAB\u0026gt;\u0026quot; let g:UltiSnipsJumpForwardTrigger=\u0026quot;\u0026lt;c-f\u0026gt;\u0026quot; let g:UltiSnipsJumpBackwardTrigger=\u0026quot;\u0026lt;c-b\u0026gt;\u0026quot; \u0026quot;au BufRead,BufNewFile *.go set filetype=go \u0026quot; ycm \u0026quot; let g:ycm_key_list_select_completion=['\u0026lt;c-n\u0026gt;'] \u0026quot; let g:ycm_key_list_previous_completion=['\u0026lt;c-p\u0026gt;'] \u0026quot; let g:ycm_key_invoke_completion = '\u0026lt;C-Space\u0026gt;' \u0026quot; \u0026quot; 关闭加载.ycm_extra_conf.py提示 \u0026quot; let g:ycm_confirm_extra_conf=0 \u0026quot; \u0026quot; 开启 YCM 基于标签引擎 \u0026quot; let g:ycm_collect_identifiers_from_tags_files=1 \u0026quot; \u0026quot; 从第2个键入字符就开始罗列匹配项 \u0026quot; let g:ycm_min_num_of_chars_for_completion=1 \u0026quot; \u0026quot; 禁止缓存匹配项,每次都重新生成匹配项 \u0026quot; let g:ycm_cache_omnifunc=0 \u0026quot; \u0026quot; 语法关键字补全 \u0026quot; let g:ycm_seed_identifiers_with_syntax=1 \u0026quot; \u0026quot; 设置在下面几种格式的文件上屏蔽ycm \u0026quot; let g:ycm_filetype_blacklist = { \u0026quot; \\ 'typescript.tsx' : 1, \u0026quot; \\ 'typescript' : 1, \u0026quot; \\} \u0026quot; \u0026quot; 注释和字符串中的文字也会被收入补全 \u0026quot; let g:ycm_collect_identifiers_from_comments_and_strings = 0 \u0026quot; \u0026quot; 输入第2个字符开始补全 \u0026quot; let g:ycm_min_num_of_chars_for_completion=2 \u0026quot; 注释 \u0026quot; Add spaces after comment delimiters by default let g:NERDSpaceDelims = 1 \u0026quot; Use compact syntax for prettified multi-line comments let g:NERDCompactSexyComs = 1 \u0026quot; Align line-wise comment delimiters flush left instead of following code indentation let g:NERDDefaultAlign = 'left' \u0026quot; Set a language to use its alternate delimiters by default let g:NERDAltDelims_java = 1 \u0026quot; Add your own custom formats or override the defaults let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } } \u0026quot; Allow commenting and inverting empty lines (useful when commenting a region) let g:NERDCommentEmptyLines = 1 \u0026quot; Enable trimming of trailing whitespace when uncommenting let g:NERDTrimTrailingWhitespace = 1 \u0026quot; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines = 1 \u0026quot; coc let g:coc_global_extensions = [ \\ 'coc-json', \\ 'coc-html', \\ 'coc-css', \\ ] set cmdheight=2 set updatetime=300 set shortmess+=c set signcolumn=yes au BufNewFile,BufRead *.ts setlocal filetype=typescript au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition) nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition) nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation) nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references) nmap \u0026lt;leader\u0026gt;rn \u0026lt;Plug\u0026gt;(coc-rename) nmap \u0026lt;silent\u0026gt; [c \u0026lt;Plug\u0026gt;(coc-diagnostic-prev) nmap \u0026lt;silent\u0026gt; ]c \u0026lt;Plug\u0026gt;(coc-diagnostic-next) nmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) nmap \u0026lt;leader\u0026gt;ac \u0026lt;Plug\u0026gt;(coc-codeaction) nmap \u0026lt;leader\u0026gt;qf \u0026lt;Plug\u0026gt;(coc-fix-current) nmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;S-TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select-backword) xmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) \u0026quot; 显示文档 nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt; \u0026quot; 回车：补全框?确认补全:回车可以撤回 inoremap \u0026lt;expr\u0026gt; \u0026lt;cr\u0026gt; pumvisible() ? \u0026quot;\\\u0026lt;C-y\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\u0026quot; \u0026quot; \u0026lt;c-c\u0026gt;触发补全 inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-c\u0026gt; coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026quot;\\\u0026lt;C-p\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;C-h\u0026gt;\u0026quot; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; \\ pumvisible() ? \u0026quot;\\\u0026lt;C-n\u0026gt;\u0026quot; : \\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026quot;\\\u0026lt;TAB\u0026gt;\u0026quot; : \\ coc#refresh() \u0026quot; Use `:Format` to format current buffer command! -nargs=0 Format :call CocAction('format') \u0026quot; Use `:Fold` to fold current buffer command! -nargs=? Fold :call CocAction('fold', \u0026lt;f-args\u0026gt;) \u0026quot; set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')} \u0026quot; autocmd CursorHold * silent call CocActionAsync('highlight') function! s:show_documentation() if (index(['vim','help'], \u0026amp;filetype) \u0026gt;= 0) execute 'h '.expand('\u0026lt;cword\u0026gt;') else call CocAction('doHover') endif endfunction function! s:check_back_space() abort let col = col('.') - 1 return !col || getline('.')[col - 1] =~# '\\s' endfunction \u0026quot; -------------------- plug ------------------------ call plug#begin('~/.vim/plugins') Plug 'dracula/vim', { 'as': 'dracula' } Plug 'mhinz/vim-startify' Plug 'SirVer/ultisnips' Plug 'jiangmiao/auto-pairs' Plug 'vim-airline/vim-airline' Plug 'vim-airline/vim-airline-themes' Plug 'scrooloose/nerdcommenter' \u0026quot; NERDTree Plug 'scrooloose/nerdtree' \u0026quot; git Plug 'Xuyuanp/nerdtree-git-plugin' \u0026quot; icon \u0026quot; Plug 'ryanoasis/vim-devicons' \u0026quot; coc \u0026quot; Plug 'neoclide/coc.nvim', {'do': 'yarn install --frozen-lockfile' } \u0026quot; golang \u0026quot; Plug 'fatih/vim-go' \u0026quot; typescript \u0026quot; Plug 'leafgarland/typescript-vim', {'for': ['typescript', 'typescript.tsx', 'js']} \u0026quot; prettier \u0026quot;Plug 'prettier/vim-prettier', { \u0026quot; \\ 'do': 'yarn install', \u0026quot; \\ 'for': ['javascript', 'typescript', 'css', 'less', 'scss', 'json', 'graphql', 'markdown', 'vue', 'yaml', 'html'] } \u0026quot;Plug 'Valloric/YouCompleteMe' call plug#end() \u0026quot; 替换函数 \u0026quot; 参数说明： \u0026quot; confirm：是否替换前逐一确认 \u0026quot; wholeword：是否整词匹配 \u0026quot; replace：被替换字符串 function! Replace(confirm, wholeword, replace) wa let flag = '' if a:confirm let flag .= 'gec' else let flag .= 'ge' endif let search = '' if a:wholeword let search .= '\\\u0026lt;' . escape(expand('\u0026lt;cword\u0026gt;'), '/\\.*$^~[') . '\\\u0026gt;' else let search .= expand('\u0026lt;cword\u0026gt;') endif let replace = escape(a:replace, '/\\\u0026amp;~') execute 'argdo %s/' . search . '/' . replace . '/' . flag . '| update' endfunction \u0026quot; 不确认、非整词 nnoremap \u0026lt;Leader\u0026gt;R :call Replace(0, 0, input('Replace '.expand('\u0026lt;cword\u0026gt;').' with: '))\u0026lt;CR\u0026gt; \u0026quot; 不确认、整词 nnoremap \u0026lt;Leader\u0026gt;rw :call Replace(0, 1, input('Replace '.expand('\u0026lt;cword\u0026gt;').' with: '))\u0026lt;CR\u0026gt; \u0026quot; 确认、非整词 nnoremap \u0026lt;Leader\u0026gt;rc :call Replace(1, 0, input('Replace '.expand('\u0026lt;cword\u0026gt;').' with: '))\u0026lt;CR\u0026gt; \u0026quot; 确认、整词 nnoremap \u0026lt;Leader\u0026gt;rcw :call Replace(1, 1, input('Replace '.expand('\u0026lt;cword\u0026gt;').' with: '))\u0026lt;CR\u0026gt; nnoremap \u0026lt;Leader\u0026gt;rwc :call Replace(1, 1, input('Replace '.expand('\u0026lt;cword\u0026gt;').' with: '))\u0026lt;CR\u0026gt;  ","id":25,"section":"posts","summary":"\u0026quot; .vimrc \u0026quot; Configuration file for vim set modelines=0 \u0026quot; Don't write backup file if vim is being called by \u0026quot;crontab -e\u0026quot; \u0026quot; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026quot; Don't write backup file if vim is being called by \u0026quot;chpass\u0026quot; \u0026quot; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026quot; \u0026lt;leader\u0026gt; let g:mapleader=\u0026quot;,\u0026quot; \u0026quot; 去掉有关vi一致性模式","tags":["vim"],"title":"vimrc","uri":"https://rx-78-kum0.github.io/2019/06/vimrc/","year":"2019"},{"content":" golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true  一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:\nvar a interface{} fmt.Println(a) // a为nil  一个刚好包含 nil 指针的接口值: 赋值给后，interface 类型变量的动态类型不为 nil，动态值为 nil.\nvar a interface{} var b *string a = b fmt.Println(a) // 此时a的动态类型为*string，动态值为nil  这两种对象比较: func main(){ var a interface{} // nil var b *string // nil a = b fmt.Println(a == nil) // false fmt.Println(b == nil) // true fmt.Println(b == a) // true }    a = nil 为 false: b 赋值给 a, a 的动态类型为 *string, 动态值为 nil, 所以 a = nil 为 false.\n// 空接口 type eface struct { _type *_type // 类型信息 data unsafe.Pointer // 指向数据的指针 } // 带有方法的接口 type iface struct { tab *itab // 存储type信息还有结构实现方法的集合 data unsafe.Pointer // 指向数据的指针 }    根据 interface 的底层实现, a = b 实则是 a.data = unsafe.Pointer(\u0026amp;b). a = nil 才是 a.data = nil.\n  b == nil 为 true: b 是一个空的指针(非接口)类型.\n  b == a 为 true: 值都为 nil, b 是一个空的指针(非接口)类型.\n  ","id":26,"section":"posts","summary":"golang 接口值: 一个包含 nil 指针的接口不是 nil 接口. 一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的. 接口值由两个部分组成: 一个具体的类","tags":["golang"],"title":"一个包含 nil 指针的接口不是 nil 接口","uri":"https://rx-78-kum0.github.io/2019/03/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/","year":"2019"},{"content":"{ // editor \u0026quot;editor.fontSize\u0026quot;: 14, \u0026quot;editor.snippetSuggestions\u0026quot;: \u0026quot;top\u0026quot;, \u0026quot;editor.formatOnSave\u0026quot;: true, \u0026quot;explorer.confirmDragAndDrop\u0026quot;: true, \u0026quot;explorer.confirmDelete\u0026quot;: false, \u0026quot;editor.detectIndentation\u0026quot;: false, \u0026quot;files.autoSave\u0026quot;: \u0026quot;off\u0026quot;, // \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;'FuraCode', Menlo, Monaco, 'Courier New', monospace\u0026quot;, \u0026quot;editor.fontLigatures\u0026quot;: true, \u0026quot;workbench.iconTheme\u0026quot;: \u0026quot;material-icon-theme\u0026quot;, \u0026quot;workbench.colorTheme\u0026quot;: \u0026quot;Nebula\u0026quot;, // prettier \u0026quot;prettier.printWidth\u0026quot;: 120, \u0026quot;editor.tabSize\u0026quot;: 2, \u0026quot;prettier.singleQuote\u0026quot;: true, \u0026quot;prettier.semi\u0026quot;: true, // typescript \u0026quot;typescript.updateImportsOnFileMove.enabled\u0026quot;: \u0026quot;always\u0026quot;, // emmet \u0026quot;emmet.includeLanguages\u0026quot;: { \u0026quot;javascript\u0026quot;: \u0026quot;javascriptreact\u0026quot;, \u0026quot;typescript\u0026quot;: \u0026quot;typescriptreact\u0026quot; }, \u0026quot;emmet.triggerExpansionOnTab\u0026quot;: true, // 装饰器 \u0026quot;javascript.implicitProjectConfig.experimentalDecorators\u0026quot;: true, // stylus \u0026quot;stylusSupremacy.insertColons\u0026quot;: false, // 是否插入冒号 \u0026quot;stylusSupremacy.insertSemicolons\u0026quot;: false, // 是否插入分好 \u0026quot;stylusSupremacy.insertBraces\u0026quot;: false, // 是否插入大括号 \u0026quot;stylusSupremacy.insertNewLineAroundImports\u0026quot;: true, // import之后是否换行 \u0026quot;stylusSupremacy.insertNewLineAroundBlocks\u0026quot;: true, \u0026quot;stylusSupremacy.insertSpaceAfterComment\u0026quot;: true, \u0026quot;window.zoomLevel\u0026quot;: 0, // Formatter \u0026quot;[javascript]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;vscode.typescript-language-features\u0026quot; }, \u0026quot;[typescript]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot; }, \u0026quot;[json]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot; }, \u0026quot;[jsonc]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot; }, \u0026quot;[typescriptreact]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot; }, \u0026quot;[html]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot; }, \u0026quot;search.followSymlinks\u0026quot;: false, // vim \u0026quot;vim.useSystemClipboard\u0026quot;: true, \u0026quot;vim.hlsearch\u0026quot;: true, \u0026quot;vim.smartcase\u0026quot;: true, \u0026quot;vim.leader\u0026quot;: \u0026quot;,\u0026quot;, \u0026quot;vim.highlightedyank.enable\u0026quot;: true, \u0026quot;vim.highlightedyank.duration\u0026quot;: 1000, \u0026quot;vim.highlightedyank.color\u0026quot;: \u0026quot;rgba(250, 240, 170, 0.5)\u0026quot;, \u0026quot;vim.history\u0026quot;: 100, // \u0026quot;vim.cursorStylePerMode.insert\u0026quot;: \u0026quot;line\u0026quot;, // \u0026quot;vim.cursorStylePerMode.normal\u0026quot;: \u0026quot;underline\u0026quot;, // \u0026quot;vim.cursorStylePerMode.replace\u0026quot;: \u0026quot;underline\u0026quot;, // \u0026quot;vim.cursorStylePerMode.visual\u0026quot;: \u0026quot;blink\u0026quot;, // \u0026quot;vim.cursorStylePerMode.visualblock\u0026quot;: \u0026quot;blink\u0026quot;, // \u0026quot;vim.cursorStylePerMode.visualline\u0026quot;: \u0026quot;underline\u0026quot;, \u0026quot;vim.easymotion\u0026quot;: true, \u0026quot;vim.easymotionMarkerFontSize\u0026quot;: \u0026quot;16\u0026quot;, \u0026quot;vim.easymotionMarkerHeight\u0026quot;: 16, \u0026quot;vim.easymotionMarkerWidthPerChar\u0026quot;: 9, \u0026quot;vim.normalModeKeyBindings\u0026quot;: [], \u0026quot;vim.normalModeKeyBindingsNonRecursive\u0026quot;: [ { \u0026quot;before\u0026quot;: [\u0026quot;d\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;d\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;d\u0026quot;, \u0026quot;d\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;d\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;D\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;D\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;t\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;x\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;X\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;X\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;s\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;s\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;S\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;S\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;c\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;c\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;C\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;C\u0026quot;] } ], \u0026quot;vim.visualModeKeyBindings\u0026quot;: [ { \u0026quot;before\u0026quot;: [\u0026quot;s\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;s\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;S\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;S\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;)\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;)\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;}\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;{\u0026quot;, \u0026quot;}\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;]\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;'\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;'\u0026quot;, \u0026quot;'\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;\\\u0026quot;\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;\u0026gt;\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;\u0026lt;\u0026quot;, \u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] }, { \u0026quot;before\u0026quot;: [\u0026quot;z\u0026quot;, \u0026quot;`\u0026quot;], \u0026quot;after\u0026quot;: [\u0026quot;c\u0026quot;, \u0026quot;`\u0026quot;, \u0026quot;`\u0026quot;, \u0026quot;\u0026lt;Esc\u0026gt;\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;p\u0026quot;] } ], \u0026quot;vim.handleKeys\u0026quot;: { \u0026quot;\u0026lt;C-a\u0026gt;\u0026quot;: false, \u0026quot;\u0026lt;C-f\u0026gt;\u0026quot;: false } }  ","id":27,"section":"posts","summary":"{ // editor \u0026quot;editor.fontSize\u0026quot;: 14, \u0026quot;editor.snippetSuggestions\u0026quot;: \u0026quot;top\u0026quot;, \u0026quot;editor.formatOnSave\u0026quot;: true, \u0026quot;explorer.confirmDragAndDrop\u0026quot;: true, \u0026quot;explorer.confirmDelete\u0026quot;: false, \u0026quot;editor.detectIndentation\u0026quot;: false, \u0026quot;files.autoSave\u0026quot;: \u0026quot;off\u0026quot;, // \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;'FuraCode', Menlo, Monaco, 'Courier New', monospace\u0026quot;, \u0026quot;editor.fontLigatures\u0026quot;: true, \u0026quot;workbench.iconTheme\u0026quot;: \u0026quot;material-icon-theme\u0026quot;, \u0026quot;workbench.colorTheme\u0026quot;: \u0026quot;Nebula\u0026quot;, // prettier \u0026quot;prettier.printWidth\u0026quot;: 120, \u0026quot;editor.tabSize\u0026quot;: 2, \u0026quot;prettier.singleQuote\u0026quot;: true, \u0026quot;prettier.semi\u0026quot;: true, // typescript \u0026quot;typescript.updateImportsOnFileMove.enabled\u0026quot;: \u0026quot;always\u0026quot;, // emmet \u0026quot;emmet.includeLanguages\u0026quot;: { \u0026quot;javascript\u0026quot;: \u0026quot;javascriptreact\u0026quot;, \u0026quot;typescript\u0026quot;: \u0026quot;typescriptreact\u0026quot; }, \u0026quot;emmet.triggerExpansionOnTab\u0026quot;: true, // 装饰器 \u0026quot;javascript.implicitProjectConfig.experimentalDecorators\u0026quot;: true, // stylus \u0026quot;stylusSupremacy.insertColons\u0026quot;: false, // 是否插","tags":["vscode"],"title":"vscode","uri":"https://rx-78-kum0.github.io/2019/03/vscode/","year":"2019"}],"tags":[{"title":"angular","uri":"https://rx-78-kum0.github.io/tags/angular/"},{"title":"css","uri":"https://rx-78-kum0.github.io/tags/css/"},{"title":"docker","uri":"https://rx-78-kum0.github.io/tags/docker/"},{"title":"emacs","uri":"https://rx-78-kum0.github.io/tags/emacs/"},{"title":"golang","uri":"https://rx-78-kum0.github.io/tags/golang/"},{"title":"helloworld","uri":"https://rx-78-kum0.github.io/tags/helloworld/"},{"title":"mac","uri":"https://rx-78-kum0.github.io/tags/mac/"},{"title":"mysql","uri":"https://rx-78-kum0.github.io/tags/mysql/"},{"title":"nasm","uri":"https://rx-78-kum0.github.io/tags/nasm/"},{"title":"shell","uri":"https://rx-78-kum0.github.io/tags/shell/"},{"title":"tools","uri":"https://rx-78-kum0.github.io/tags/tools/"},{"title":"typescript","uri":"https://rx-78-kum0.github.io/tags/typescript/"},{"title":"vim","uri":"https://rx-78-kum0.github.io/tags/vim/"},{"title":"vscode","uri":"https://rx-78-kum0.github.io/tags/vscode/"},{"title":"web","uri":"https://rx-78-kum0.github.io/tags/web/"},{"title":"操作系统","uri":"https://rx-78-kum0.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"汇编","uri":"https://rx-78-kum0.github.io/tags/%E6%B1%87%E7%BC%96/"}]}